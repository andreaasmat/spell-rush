<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spell Rush</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-wrapper {
            position: relative;
            width: 100%;
            max-width: 480px;
            height: 100vh;
            max-height: 900px;
            background: #46a302;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            transform: translateZ(0);
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: white;
            font-size: 20px;
            font-weight: 900;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 5;
        }

        .hud-box {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            pointer-events: auto;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.3s, transform 0.3s;
        }

        h1 {
            color: #58cc02;
            font-size: 36px;
            margin-bottom: 10px;
            font-weight: 900;
            text-transform: uppercase;
            text-shadow: 2px 2px 0px #eee;
        }

        .key-badge {
            display: inline-block;
            background: #333;
            color: white;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 12px;
            margin: 0 2px;
            font-weight: bold;
        }

        .btn {
            background-color: #58cc02;
            color: white;
            border: none;
            padding: 18px 40px;
            font-size: 20px;
            font-family: 'Nunito', sans-serif;
            font-weight: 900;
            border-radius: 20px;
            border-bottom: 6px solid #46a302;
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            max-width: 300px;
            box-shadow: 0 4px 10px rgba(88, 204, 2, 0.3);
        }

        .btn:active {
            transform: translateY(6px);
            border-bottom-width: 0;
            box-shadow: none;
            margin-top: 6px;
        }

        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 140px;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 10;
            pointer-events: none;
        }

        .control-group {
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .touch-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: white;
            user-select: none;
            backdrop-filter: blur(4px);
            transition: all 0.1s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .touch-btn:active,
        .touch-btn.active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.92);
        }

        .turbo-btn {
            width: 90px;
            height: 90px;
            background: rgba(255, 200, 0, 0.25);
            border-color: rgba(255, 200, 0, 0.6);
            align-self: flex-end;
            font-size: 36px;
        }

        .turbo-btn:active,
        .turbo-btn.active {
            background: rgba(255, 200, 0, 0.5);
        }

        .hidden {
            display: none !important;
            opacity: 0;
        }

        @media (min-width: 700px) {
            #mobile-controls {
                display: none;
            }
        }
    </style>
</head>

<body>

    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>

        <div class="ui-layer">
            <div class="hud" id="hud">
                <div class="hud-box">‚úÖ <span id="score-display">0</span>/10</div>
                <div class="hud-box">‚è±Ô∏è <span id="time-display">0.0</span>s</div>
            </div>

            <div id="mobile-controls">
                <div class="control-group" style="align-items: flex-end;">
                    <div class="touch-btn" id="btn-left" onpointerdown="moveLeft()" onpointerup="stopSteer()">‚¨ÖÔ∏è</div>
                    <div class="touch-btn" id="btn-right" onpointerdown="moveRight()" onpointerup="stopSteer()">‚û°Ô∏è</div>
                </div>
                <div class="control-group">
                    <div class="touch-btn turbo-btn" id="btn-turbo" onpointerdown="startTurbo()"
                        onpointerup="stopTurbo()">‚ö°</div>
                </div>
            </div>
        </div>

        <div id="start-screen" class="screen">
            <h1 style="color: #58cc02; margin-bottom: 20px;">Spell Rush</h1>

            <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 25px;">
                <div style="text-align: left;">
                    <p style="font-size: 18px; color: #444; margin: 0; font-weight: 700;">Pick the correct spelling</p>
                    <p style="font-size: 14px; color: #666; margin: 5px 0 0 0;">to win the race!</p>
                </div>
                <img src="duo-owl-happy.webp" alt="Happy Duo" style="width: 80px; height: auto;">
            </div>

            <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 30px;">
                <img src="duo-owl-crash-fail.webp" alt="Crash Duo" style="width: 70px; height: auto;">
                <div style="text-align: left;">
                    <p style="font-size: 16px; color: #ff4b4b; margin: 0; font-weight: 700;">Avoid obstacles & typos!</p>
                    <p style="font-size: 13px; color: #888; margin: 5px 0 0 0;">Wrong spells = crash üí•</p>
                </div>
            </div>

            <button class="btn" onclick="startGame()">Start Race!</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const startScreen = document.getElementById('start-screen');

        const duoHappyImg = new Image();
        duoHappyImg.src = 'duo-owl-happy.webp';
        const duoCrashImg = new Image();
        duoCrashImg.src = 'duo-owl-crash-fail.webp';
        let duoImagesLoaded = 0;
        duoHappyImg.onload = () => { duoImagesLoaded++; };
        duoCrashImg.onload = () => { duoImagesLoaded++; };

        let duoCrashTimer = 0;

        let state = 'menu';
        let lastTime = 0;
        let startTime = 0;
        let score = 0;
        let mistakes = [];
        let shuffledWords = [];
        let wordIndex = 0;
        let wordsAttempted = 0;
        const targetScore = 10;

        let speed = 0;
        const baseSpeed = 300;
        const turboSpeed = 850;
        const acceleration = 500;
        const braking = 700;
        let isTurboPressed = false;

        let roadY = 0;
        let roadWidth = 280;
        let laneWidth = 140;
        const segmentHeight = 50;

        const car = {
            x: 0,
            y: 0,
            width: 60,
            height: 90,
            lane: 0,
            targetX: 0,
            moveSpeed: 15,
            color: '#58cc02',
            wobble: 0,
            rotation: 0,
            spinning: false,
            exhaustTimer: 0
        };

        let decorations = [];
        let decorTimer = 0;
        let particles = [];
        let words = [];
        let obstacles = [];

        const wordPairs = [
            { correct: "decisi√≥n", wrong: "desici√≥n" },
            { correct: "conduzco", wrong: "condusco" },
            { correct: "hizo", wrong: "hiso" },
            { correct: "√°rbol", wrong: "arbol" },
            { correct: "hecho", wrong: "echo" },
            { correct: "beneficio", wrong: "benefisio" },
            { correct: "tambi√©n", wrong: "tanbi√©n" },
            { correct: "huevo", wrong: "g√ºevo" },
            { correct: "zanahoria", wrong: "sanahoria" },
            { correct: "quiz√°s", wrong: "quis√°s" },
        ];

        let nextSpawnY = -500;
        let nextObstacleY = -200;

        let shakeDuration = 0;
        let flashColor = null;
        let flashDuration = 0;

        function resize() {
            const wrapper = document.getElementById('game-wrapper');
            const dpr = window.devicePixelRatio || 1;
            canvas.width = wrapper.offsetWidth * dpr;
            canvas.height = wrapper.offsetHeight * dpr;
            ctx.scale(dpr, dpr);

            const logicalWidth = wrapper.offsetWidth;
            const logicalHeight = wrapper.offsetHeight;

            roadWidth = Math.min(logicalWidth * 0.85, 340);
            laneWidth = roadWidth / 2;
            car.y = logicalHeight - 180;
            updateCarTarget();
            car.x = car.targetX;
        }
        window.addEventListener('resize', resize);

        function updateCarTarget() {
            const wrapper = document.getElementById('game-wrapper');
            const centerX = wrapper.offsetWidth / 2;
            if (car.lane === 0) {
                car.targetX = centerX - laneWidth / 2 - car.width / 2;
            } else {
                car.targetX = centerX + laneWidth / 2 - car.width / 2;
            }
        }

        function moveLeft() { if (state === 'playing') { car.lane = 0; updateCarTarget(); document.getElementById('btn-left').classList.add('active'); } }
        function moveRight() { if (state === 'playing') { car.lane = 1; updateCarTarget(); document.getElementById('btn-right').classList.add('active'); } }
        function stopSteer() {
            document.getElementById('btn-left').classList.remove('active');
            document.getElementById('btn-right').classList.remove('active');
        }

        function startTurbo() { isTurboPressed = true; document.getElementById('btn-turbo').classList.add('active'); }
        function stopTurbo() { isTurboPressed = false; document.getElementById('btn-turbo').classList.remove('active'); }

        document.addEventListener('keydown', (e) => {
            if (state !== 'playing') return;
            if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft();
            if (e.key === 'ArrowRight' || e.key === 'd') moveRight();
            if (e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w') startTurbo();
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') stopSteer();
            if (e.key === 'ArrowRight' || e.key === 'd') stopSteer();
            if (e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w') stopTurbo();
        });

        function startGame() {
            resize();
            state = 'playing';
            score = 0;
            mistakes = [];
            shuffledWords = [...wordPairs].sort(() => Math.random() - 0.5);
            wordIndex = 0;
            wordsAttempted = 0;
            speed = 0;
            isTurboPressed = false;
            words = [];
            obstacles = [];
            decorations = [];
            particles = [];
            duoCrashTimer = 0;

            startScreen.classList.add('hidden');
            scoreDisplay.innerText = 0;
            timeDisplay.innerText = "0.0";

            startTime = Date.now();
            lastTime = performance.now();
            nextSpawnY = -400;
            nextObstacleY = -200;

            car.lane = 0;
            car.rotation = 0;
            car.spinning = false;
            updateCarTarget();
            car.x = car.targetX;

            requestAnimationFrame(loop);
        }

        function loop(timestamp) {
            if (state !== 'playing') return;
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;
            update(dt);
            draw();
            requestAnimationFrame(loop);
        }

        function update(dt) {
            const wrapper = document.getElementById('game-wrapper');
            const logicalHeight = wrapper.offsetHeight;

            const currentTime = (Date.now() - startTime) / 1000;
            timeDisplay.innerText = currentTime.toFixed(1);

            let targetSpeed = isTurboPressed ? turboSpeed : baseSpeed;
            if (car.spinning) targetSpeed = 0;

            if (speed < targetSpeed) {
                speed += acceleration * dt;
            } else if (speed > targetSpeed) {
                speed -= braking * dt;
            }

            car.x += (car.targetX - car.x) * car.moveSpeed * dt;

            if (car.spinning) {
                car.rotation += 15 * dt;
                if (car.rotation > Math.PI * 2) {
                    car.rotation = 0;
                    car.spinning = false;
                }
            } else {
                car.wobble = (speed > 600) ? (Math.random() - 0.5) * 1.5 : 0;
            }

            roadY += speed * dt;
            if (roadY >= segmentHeight * 2) roadY -= segmentHeight * 2;

            decorTimer -= dt;
            if (decorTimer <= 0) {
                spawnDecoration(wrapper.offsetWidth);
                decorTimer = (Math.random() * 0.5 + 0.2) * (800 / (speed + 100));
            }
            decorations.forEach((d, i) => {
                d.y += speed * dt;
                if (d.y > logicalHeight) decorations.splice(i, 1);
            });

            nextSpawnY += speed * dt;
            if (nextSpawnY > 800 && wordIndex < shuffledWords.length) {
                spawnWordPair(wrapper.offsetWidth);
                nextSpawnY = 0;
                nextObstacleY = -200;
            }

            nextObstacleY += speed * dt;
            if (nextObstacleY > 300 && nextSpawnY < 500) {
                if (Math.random() > 0.4) spawnObstacle(wrapper.offsetWidth);
                nextObstacleY = 0;
            }

            [words, obstacles].forEach(list => {
                for (let i = list.length - 1; i >= 0; i--) {
                    let e = list[i];
                    e.y += speed * dt;

                    if (!e.hit && checkCollision(car, e)) {
                        if (e.type === 'word') handleWordCollision(e);
                        else handleObstacleCollision(e);
                    }

                    if (e.y > logicalHeight + 100) list.splice(i, 1);
                }
            });

            if (shakeDuration > 0) shakeDuration -= dt;
            if (flashDuration > 0) flashDuration -= dt;
            if (duoCrashTimer > 0) duoCrashTimer -= dt;

            car.exhaustTimer += dt;
            if (isTurboPressed && speed > 400 && !car.spinning && car.exhaustTimer > 0.05) {
                spawnParticles();
                car.exhaustTimer = 0;
            }
            updateParticles(dt);
        }

        function checkCollision(player, obj) {
            const padding = 15;
            return (
                player.x + padding < obj.x + obj.width - padding &&
                player.x + player.width - padding > obj.x + padding &&
                player.y + padding < obj.y + obj.height - padding &&
                player.y + player.height - padding > obj.y + padding
            );
        }

        function spawnDecoration(width) {
            const side = Math.random() > 0.5 ? -1 : 1;
            const centerX = width / 2;
            decorations.push({
                type: Math.random() > 0.7 ? 'tree' : 'bush',
                x: centerX + (side * (roadWidth / 2 + 50 + Math.random() * 80)),
                y: -100,
                scale: Math.random() * 0.4 + 0.8,
                colorVar: Math.random() * 20 - 10
            });
        }

        function spawnWordPair(width) {
            const pair = shuffledWords[wordIndex++ % shuffledWords.length];
            const correctLane = Math.random() > 0.5 ? 0 : 1;
            const centerX = width / 2;
            const pairId = wordIndex;
            const createWord = (text, isCorrect, lane, correctText) => ({
                type: 'word',
                text: text,
                isCorrect: isCorrect,
                correctText: correctText,
                pairId: pairId,
                lane: lane,
                x: lane === 0 ? centerX - laneWidth / 2 - 60 : centerX + laneWidth / 2 - 60,
                y: -100,
                width: 120,
                height: 55,
                hit: false,
                color: '#f0f0f0',
                textColor: '#333'
            });
            words.push(createWord(pair.correct, true, correctLane, pair.correct));
            words.push(createWord(pair.wrong, false, correctLane === 0 ? 1 : 0, pair.correct));
        }

        function spawnObstacle(width) {
            const type = Math.random() > 0.5 ? 'cone' : 'banana';
            const lane = Math.random() > 0.5 ? 0 : 1;
            const centerX = width / 2;
            const xPos = lane === 0 ? centerX - laneWidth / 2 : centerX + laneWidth / 2;

            obstacles.push({
                type: type,
                x: xPos - 25,
                y: -100,
                width: 50,
                height: 50,
                hit: false,
                wobbleOffset: Math.random() * Math.PI
            });
        }

        function handleWordCollision(word) {
            word.hit = true;
            wordsAttempted++;
            words.forEach(w => { if (w.pairId === word.pairId) w.hit = true; });
            if (word.isCorrect) {
                score++;
                scoreDisplay.innerText = score;
                word.color = '#58cc02';
                word.textColor = '#fff';
                triggerFlash('green');
                for (let i = 0; i < 12; i++) spawnConfetti(word.x + word.width / 2, word.y);
            } else {
                speed = 0;
                shakeDuration = 0.5;
                word.color = '#ff4b4b';
                word.textColor = '#fff';
                triggerFlash('red');
                duoCrashTimer = 1.5;
                mistakes.push({ wrong: word.text, correct: word.correctText });
            }
            if (wordsAttempted >= targetScore) endGame();
        }

        function handleObstacleCollision(obs) {
            obs.hit = true;
            if (obs.type === 'cone') {
                speed = 0;
                shakeDuration = 0.6;
                triggerFlash('red');
                duoCrashTimer = 1.5;
                for (let i = 0; i < 8; i++) {
                    particles.push({
                        x: obs.x + 25, y: obs.y + 25,
                        vx: (Math.random() - 0.5) * 400, vy: (Math.random() - 0.5) * 400,
                        life: 0.6, color: '#e65100', size: 6, isConfetti: false
                    });
                }
            } else if (obs.type === 'banana') {
                speed = speed * 0.4;
                car.spinning = true;
                shakeDuration = 0.3;
                duoCrashTimer = 2;
            }
        }

        function spawnParticles() {
            particles.push({
                x: car.x + car.width / 2 + (Math.random() - 0.5) * 20,
                y: car.y + car.height - 10,
                vx: (Math.random() - 0.5) * 50,
                vy: 200 + Math.random() * 150,
                life: 0.5,
                color: isTurboPressed ? `rgba(255, ${200 + Math.random() * 55}, 0, ${Math.random() * 0.5 + 0.3})` : 'rgba(200,200,200,0.3)',
                size: Math.random() * 6 + 4,
                isConfetti: false
            });
        }

        function spawnConfetti(x, y) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 400,
                vy: (Math.random() - 0.5) * 400,
                life: 0.8,
                color: `hsl(${Math.random() * 360}, 100%, 60%)`,
                size: Math.random() * 7 + 3,
                isConfetti: true
            });
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                if (!p.isConfetti) p.y += speed * dt;
                p.life -= dt;
                p.size *= 0.95;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function endGame() {
            state = 'gameover';
            const finalTime = (Date.now() - startTime) / 1000;

            setTimeout(() => {
                const mistakesParam = encodeURIComponent(JSON.stringify(mistakes));
                window.location.href = `resultspage.html?score=${score}&time=${finalTime.toFixed(2)}&total=${targetScore}&mistakes=${mistakesParam}`;
            }, 500);
        }

        function triggerFlash(color) {
            flashColor = color;
            flashDuration = 0.15;
        }

        function draw() {
            const wrapper = document.getElementById('game-wrapper');
            const logicalWidth = wrapper.offsetWidth;
            const logicalHeight = wrapper.offsetHeight;

            let dx = 0, dy = 0;
            if (shakeDuration > 0) {
                dx = (Math.random() - 0.5) * 12;
                dy = (Math.random() - 0.5) * 12;
            }

            ctx.clearRect(0, 0, logicalWidth, logicalHeight);
            ctx.save();
            ctx.translate(dx, dy);

            ctx.fillStyle = '#46a302';
            ctx.fillRect(0, 0, logicalWidth, logicalHeight);

            const centerX = logicalWidth / 2;
            const leftEdge = centerX - roadWidth / 2;

            const roadGradient = ctx.createLinearGradient(0, 0, 0, logicalHeight);
            roadGradient.addColorStop(0, '#444');
            roadGradient.addColorStop(1, '#555');
            ctx.fillStyle = roadGradient;
            ctx.fillRect(leftEdge, 0, roadWidth, logicalHeight);

            const numSegments = Math.ceil(logicalHeight / segmentHeight) + 2;
            const offsetY = roadY % (segmentHeight * 2);

            for (let i = -1; i < numSegments; i++) {
                const yPos = i * segmentHeight + offsetY - segmentHeight;
                const isRed = (i % 2 === 0);
                ctx.fillStyle = isRed ? '#e63946' : '#f1faee';
                ctx.fillRect(leftEdge - 18, yPos, 18, segmentHeight + 1);
                ctx.fillRect(leftEdge + roadWidth, yPos, 18, segmentHeight + 1);
            }

            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255,255,255,0.9)';
            ctx.lineWidth = 6;
            ctx.setLineDash([40, 40]);
            ctx.lineDashOffset = -roadY;
            ctx.moveTo(centerX, -50);
            ctx.lineTo(centerX, logicalHeight + 50);
            ctx.stroke();

            decorations.forEach(d => drawDecoration(d));
            obstacles.forEach(o => drawObstacle(o));
            words.forEach(w => drawWord(w));

            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.save();
            ctx.translate(car.x + car.width / 2 + car.wobble, car.y + car.height / 2);
            ctx.rotate(car.rotation);
            drawCar(-car.width / 2, -car.height / 2);
            ctx.restore();

            if (flashDuration > 0) {
                ctx.fillStyle = flashColor === 'green' ? 'rgba(88, 204, 2, 0.4)' : 'rgba(255, 75, 75, 0.5)';
                ctx.fillRect(0, 0, logicalWidth, logicalHeight);
            }

            const vignette = ctx.createRadialGradient(centerX, logicalHeight / 2, logicalHeight / 3, centerX, logicalHeight / 2, logicalHeight);
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.3)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, logicalWidth, logicalHeight);

            if (speed > 600) {
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    let lx = (Date.now() / (10 + i) + i * 100) % logicalWidth;
                    ctx.beginPath();
                    ctx.moveTo(lx, 0);
                    ctx.lineTo(lx, logicalHeight);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        function drawObstacle(o) {
            if (o.type === 'cone') {
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(o.x + o.width / 2, o.y + o.height - 2, 22, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#e65100';
                ctx.beginPath();
                ctx.roundRect(o.x + 5, o.y + o.height - 10, o.width - 10, 10, 3);
                ctx.fill();

                ctx.fillStyle = '#ff6d00';
                ctx.beginPath();
                ctx.moveTo(o.x + 10, o.y + o.height - 10);
                ctx.lineTo(o.x + o.width - 10, o.y + o.height - 10);
                ctx.lineTo(o.x + o.width / 2 + 2, o.y + 5);
                ctx.lineTo(o.x + o.width / 2 - 2, o.y + 5);
                ctx.fill();

                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.moveTo(o.x + 16, o.y + o.height - 20);
                ctx.lineTo(o.x + o.width - 16, o.y + o.height - 20);
                ctx.lineTo(o.x + o.width / 2 + 4, o.y + 20);
                ctx.lineTo(o.x + o.width / 2 - 4, o.y + 20);
                ctx.fill();

            } else {
                ctx.save();
                ctx.translate(o.x + o.width / 2, o.y + o.height / 2);
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(5, 15, 20, 5, 0.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.rotate(o.wobbleOffset + Date.now() / 500);
                ctx.beginPath();
                ctx.moveTo(-20, -10);
                ctx.quadraticCurveTo(0, 10, 20, -10);
                ctx.quadraticCurveTo(5, 25, -20, -10);
                ctx.fillStyle = '#ffeb3b';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#fbc02d';
                ctx.stroke();

                ctx.fillStyle = '#5d4037';
                ctx.beginPath();
                ctx.arc(-20, -10, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(20, -10, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function drawWord(w) {
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 5;

            ctx.fillStyle = w.color;
            ctx.beginPath();
            ctx.roundRect(w.x, w.y, w.width, w.height, 12);
            ctx.fill();

            ctx.shadowColor = 'transparent';

            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.roundRect(w.x, w.y + w.height - 8, w.width, 8, [0, 0, 12, 12]);
            ctx.fill();

            ctx.fillStyle = w.textColor;
            ctx.font = "800 24px 'Nunito'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(w.text, w.x + w.width / 2, w.y + w.height / 2 - 3);
        }

        function drawDecoration(d) {
            if (d.type === 'tree') {
                ctx.fillStyle = '#5D4037';
                ctx.fillRect(d.x - 6, d.y, 12, 25);

                const g = ctx.createRadialGradient(d.x, d.y - 15, 5, d.x, d.y - 15, 25 * d.scale);
                g.addColorStop(0, '#66bb6a');
                g.addColorStop(1, '#2e7d32');
                ctx.fillStyle = g;

                ctx.beginPath();
                ctx.arc(d.x, d.y - 15, 22 * d.scale, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = `rgb(100, ${180 + d.colorVar}, 100)`;
                ctx.beginPath();
                ctx.arc(d.x, d.y + 10, 15 * d.scale, 0, Math.PI * 2);
                ctx.arc(d.x + 15, d.y + 5, 18 * d.scale, 0, Math.PI * 2);
                ctx.arc(d.x - 10, d.y + 8, 12 * d.scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawCar(x, y) {
            const w = car.width;
            const h = car.height;
            const time = Date.now() / 1000;
            const centerX = x + w / 2;

            const duoSize = 85;
            const duoY = y;
            const carTopY = y + duoSize - 30;

            if (isTurboPressed && !car.spinning) {
                ctx.fillStyle = `rgba(255, 100, 0, ${Math.random() * 0.4 + 0.5})`;
                ctx.beginPath();
                ctx.moveTo(centerX - 12, carTopY + 55);
                ctx.lineTo(centerX, carTopY + 85 + Math.random() * 25);
                ctx.lineTo(centerX + 12, carTopY + 55);
                ctx.fill();

                ctx.fillStyle = `rgba(255, 200, 0, ${Math.random() * 0.3 + 0.4})`;
                ctx.beginPath();
                ctx.moveTo(centerX - 6, carTopY + 55);
                ctx.lineTo(centerX, carTopY + 70 + Math.random() * 15);
                ctx.lineTo(centerX + 6, carTopY + 55);
                ctx.fill();
            }

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(centerX, carTopY + 65, 45, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(x - 8, carTopY + 45, 14, 16, 0, 0, Math.PI * 2);
            ctx.ellipse(x + w + 8, carTopY + 45, 14, 16, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#444';
            ctx.beginPath();
            ctx.arc(x - 8, carTopY + 45, 6, 0, Math.PI * 2);
            ctx.arc(x + w + 8, carTopY + 45, 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#c62828';
            ctx.beginPath();
            ctx.roundRect(x - 5, carTopY + 35, w + 10, 25, 6);
            ctx.fill();

            ctx.fillStyle = '#555';
            ctx.fillRect(centerX - 8, carTopY + 50, 16, 12);
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(centerX, carTopY + 58, 5, 0, Math.PI * 2);
            ctx.fill();

            const bodyGrad = ctx.createLinearGradient(x, carTopY, x, carTopY + 40);
            bodyGrad.addColorStop(0, '#ef5350');
            bodyGrad.addColorStop(0.5, '#e53935');
            bodyGrad.addColorStop(1, '#c62828');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.roundRect(x - 3, carTopY, w + 6, 40, 8);
            ctx.fill();

            ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';
            ctx.beginPath();
            ctx.roundRect(x + 5, carTopY + 5, w - 10, 12, 4);
            ctx.fill();

            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(x + 8, carTopY + 7, 15, 3);

            ctx.fillStyle = '#fff';
            ctx.fillRect(x + 5, carTopY + 22, 8, 15);
            ctx.fillRect(x + w - 13, carTopY + 22, 8, 15);

            ctx.fillStyle = '#ffeb3b';
            ctx.beginPath();
            ctx.arc(centerX, carTopY + 28, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#c62828';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('1', centerX, carTopY + 29);

            const duoImg = (duoCrashTimer > 0) ? duoCrashImg : duoHappyImg;

            if (duoImagesLoaded >= 2) {
                const imgX = centerX - duoSize / 2;
                const bounce = (speed > 400) ? Math.sin(time * 15) * 2 : 0;
                ctx.drawImage(duoImg, imgX, duoY + bounce, duoSize, duoSize);
            } else {
                ctx.font = '50px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ü¶â', centerX, y + 45);
            }
        }

        if (!ctx.roundRect) {
            ctx.roundRect = function (x, y, w, h, r) {
                if (Array.isArray(r)) r = r[0];
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.beginPath();
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            }
        }
    </script>
</body>

</html>
